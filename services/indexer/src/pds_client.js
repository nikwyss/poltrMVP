import 'dotenv/config'
import process from 'node:process'
import nacl from 'tweetnacl'
import { getUserPdsCreds } from './db.js'

const PDS_INTERNAL_URL = process.env.PDS_INTERNAL_URL ?? 'http://pds.poltr.svc.cluster.local'
const GOVERNANCE_DID = process.env.PDS_GOVERNANCE_ACCOUNT_DID
const GOVERNANCE_PASSWORD = process.env.PDS_GOVERNANCE_PASSWORD
const FRONTEND_URL = process.env.FRONTEND_URL ?? 'https://poltr.ch'

const MASTER_KEY_B64 = process.env.APPVIEW_PDS_CREDS_MASTER_KEY_B64

let accessJwt = null
let refreshJwt = null
let tokenExpiresAt = 0

// Cache user sessions: did -> { accessJwt, expiresAt }
const userSessionCache = new Map()

function isConfigured() {
  return !!(GOVERNANCE_DID && GOVERNANCE_PASSWORD)
}

/**
 * Create a session (login) for the governance account on the PDS.
 */
async function createSession() {
  const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.server.createSession`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      identifier: GOVERNANCE_DID,
      password: GOVERNANCE_PASSWORD,
    }),
  })

  if (!res.ok) {
    const body = await res.text()
    throw new Error(`createSession failed (${res.status}): ${body}`)
  }

  const data = await res.json()
  accessJwt = data.accessJwt
  refreshJwt = data.refreshJwt
  // Tokens typically last 2 hours; refresh well before expiry
  tokenExpiresAt = Date.now() + 90 * 60 * 1000
}

/**
 * Refresh the session using the refresh token.
 */
async function refreshSession() {
  if (!refreshJwt) {
    return createSession()
  }

  const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.server.refreshSession`, {
    method: 'POST',
    headers: { Authorization: `Bearer ${refreshJwt}` },
  })

  if (!res.ok) {
    // Refresh failed, fall back to full login
    console.warn('refreshSession failed, falling back to createSession')
    return createSession()
  }

  const data = await res.json()
  accessJwt = data.accessJwt
  refreshJwt = data.refreshJwt
  tokenExpiresAt = Date.now() + 90 * 60 * 1000
}

/**
 * Get a valid access token, refreshing if needed.
 */
async function getAccessToken() {
  if (!accessJwt || Date.now() >= tokenExpiresAt) {
    if (refreshJwt && Date.now() < tokenExpiresAt + 30 * 60 * 1000) {
      await refreshSession()
    } else {
      await createSession()
    }
  }
  return accessJwt
}

/**
 * Create or update a Bluesky cross-post for a ballot entry.
 * On create: uses createRecord (TID rkey auto-generated by PDS).
 * On update: uses putRecord with the existing rkey to preserve the URI
 * (keeps the thread intact — replies still point to the same post).
 *
 * @param {object} record - The ballot record (with title, description, etc.)
 * @param {string} rkey - The ballot record key
 * @param {string|null} existingPostUri - AT-URI of a previous cross-post to update in-place, or null for new
 * @returns {{uri: string, cid: string}|null} The URI and CID of the bsky post, or null on failure
 */
export async function upsertBskyPost(record, rkey, existingPostUri = null) {
  if (!isConfigured()) {
    console.warn('PDS cross-post not configured (missing env vars), skipping')
    return null
  }

  const token = await getAccessToken()

  const title = record.title ?? 'New ballot'
  const description = record.description ?? ''
  const ballotUrl = `${FRONTEND_URL}/ballots/${rkey}`
  const text = `${title}\n\n${ballotUrl}`

  // Compute byte offsets for the URL facet
  const textBytes = new TextEncoder().encode(text)
  const urlBytes = new TextEncoder().encode(ballotUrl)
  const byteStart = textBytes.length - urlBytes.length
  const byteEnd = textBytes.length

  const postRecord = {
    $type: 'app.bsky.feed.post',
    text,
    embed: {
      $type: 'app.bsky.embed.external',
      external: {
        uri: ballotUrl,
        title: title,
        description: description,
      },
    },
    facets: [
      {
        index: { byteStart, byteEnd },
        features: [{ $type: 'app.bsky.richtext.facet#link', uri: ballotUrl }],
      },
    ],
    createdAt: new Date().toISOString(),
  }

  if (existingPostUri) {
    // Update in-place via putRecord — preserves the URI so replies stay linked
    const existingRkey = existingPostUri.split('/').pop()
    const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.repo.putRecord`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        repo: GOVERNANCE_DID,
        collection: 'app.bsky.feed.post',
        rkey: existingRkey,
        record: postRecord,
      }),
    })

    if (!res.ok) {
      const body = await res.text()
      throw new Error(`putRecord for bsky post update failed (${res.status}): ${body}`)
    }

    const data = await res.json()
    console.log('Cross-post updated:', data.uri)
    return { uri: data.uri, cid: data.cid }
  }

  // New cross-post via createRecord
  const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.repo.createRecord`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      repo: GOVERNANCE_DID,
      collection: 'app.bsky.feed.post',
      record: postRecord,
    }),
  })

  if (!res.ok) {
    const body = await res.text()
    throw new Error(`createRecord for bsky post failed (${res.status}): ${body}`)
  }

  const data = await res.json()
  console.log('Cross-post created:', data.uri)
  return { uri: data.uri, cid: data.cid }
}

/**
 * Create a Bluesky cross-post for an argument, as a reply to the ballot's bsky post.
 * Posts under the argument author's repo.
 *
 * @param {string} did - The DID of the argument author
 * @param {object} record - The argument record (title, body, type)
 * @param {{uri: string, cid: string}} parentPost - The ballot's bsky post URI and CID
 * @returns {{uri: string, cid: string}|null}
 */
export async function createBskyArgumentPost(did, record, parentPost) {
  const token = await createUserSession(did)
  if (!token) {
    console.warn(`No credentials for ${did}, skipping argument cross-post`)
    return null
  }

  const prefix = record.type === 'PRO' ? 'PRO' : 'CONTRA'
  const title = record.title ?? ''
  const body = record.body ?? ''
  const text = `[${prefix}] ${title}\n\n${body}`.slice(0, 300)

  const postRecord = {
    $type: 'app.bsky.feed.post',
    text,
    reply: {
      root: { uri: parentPost.uri, cid: parentPost.cid },
      parent: { uri: parentPost.uri, cid: parentPost.cid },
    },
    createdAt: new Date().toISOString(),
  }

  const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.repo.createRecord`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      repo: did,
      collection: 'app.bsky.feed.post',
      record: postRecord,
    }),
  })

  if (!res.ok) {
    const resBody = await res.text()
    throw new Error(`createRecord for bsky argument post failed (${res.status}): ${resBody}`)
  }

  const data = await res.json()
  console.log(`Argument cross-post created by ${did}:`, data.uri)
  return { uri: data.uri, cid: data.cid }
}

/**
 * Delete a Bluesky cross-post by its AT-URI.
 * Extracts the repo DID from the URI and authenticates as that user.
 */
export async function deleteBskyPost(bskyPostUri) {
  // Parse AT-URI: at://did/collection/rkey
  const parts = bskyPostUri.replace('at://', '').split('/')
  const repoDid = parts[0]
  const rkey = parts[parts.length - 1]

  // Authenticate as the post owner
  const token = await createUserSession(repoDid)
  if (!token) {
    // Fall back to governance account for older cross-posts
    if (!isConfigured()) return
    const govToken = await getAccessToken()
    const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.repo.deleteRecord`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${govToken}`,
      },
      body: JSON.stringify({
        repo: GOVERNANCE_DID,
        collection: 'app.bsky.feed.post',
        rkey,
      }),
    })
    if (!res.ok) {
      const body = await res.text()
      throw new Error(`deleteBskyPost failed (${res.status}): ${body}`)
    }
    console.log('Bsky cross-post deleted (governance):', bskyPostUri)
    return
  }

  const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.repo.deleteRecord`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      repo: repoDid,
      collection: 'app.bsky.feed.post',
      rkey,
    }),
  })

  if (!res.ok) {
    const body = await res.text()
    throw new Error(`deleteBskyPost failed (${res.status}): ${body}`)
  }

  console.log('Bsky cross-post deleted:', bskyPostUri)
}

/**
 * Decrypt a user's stored PDS app password using the master key.
 */
function decryptAppPassword(ciphertext, nonce) {
  if (!MASTER_KEY_B64) {
    throw new Error('APPVIEW_PDS_CREDS_MASTER_KEY_B64 is not set')
  }
  const masterKey = Buffer.from(MASTER_KEY_B64, 'base64')
  if (masterKey.length !== nacl.secretbox.keyLength) {
    throw new Error(`Master key must be ${nacl.secretbox.keyLength} bytes`)
  }
  const plaintext = nacl.secretbox.open(
    new Uint8Array(ciphertext),
    new Uint8Array(nonce),
    new Uint8Array(masterKey),
  )
  if (!plaintext) {
    throw new Error('Decryption failed (wrong key or corrupted data)')
  }
  return new TextDecoder().decode(plaintext)
}

/**
 * Create a PDS session for a user by decrypting their stored credentials.
 * Caches sessions for 60 minutes to avoid re-auth on every event.
 */
async function createUserSession(did) {
  const cached = userSessionCache.get(did)
  if (cached && Date.now() < cached.expiresAt) {
    return cached.accessJwt
  }

  const creds = await getUserPdsCreds(did)
  if (!creds) {
    return null
  }

  const password = decryptAppPassword(creds.ciphertext, creds.nonce)

  const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.server.createSession`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ identifier: did, password }),
  })

  if (!res.ok) {
    const body = await res.text()
    throw new Error(`createSession for user ${did} failed (${res.status}): ${body}`)
  }

  const data = await res.json()
  userSessionCache.set(did, {
    accessJwt: data.accessJwt,
    expiresAt: Date.now() + 60 * 60 * 1000,
  })
  return data.accessJwt
}

/**
 * Create an app.bsky.feed.like on behalf of a user, targeting a Bluesky cross-post.
 * Returns { uri, cid } on success, null if user has no stored credentials.
 */
export async function createBskyLike(did, bskyPostUri, bskyPostCid) {
  const token = await createUserSession(did)
  if (!token) {
    return null
  }

  const likeRecord = {
    $type: 'app.bsky.feed.like',
    subject: {
      uri: bskyPostUri,
      cid: bskyPostCid,
    },
    createdAt: new Date().toISOString(),
  }

  const res = await fetch(`${PDS_INTERNAL_URL}/xrpc/com.atproto.repo.createRecord`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      repo: did,
      collection: 'app.bsky.feed.like',
      record: likeRecord,
    }),
  })

  if (!res.ok) {
    const body = await res.text()
    throw new Error(`createBskyLike for ${did} failed (${res.status}): ${body}`)
  }

  const data = await res.json()
  console.log('Bsky cross-like created:', data.uri)
  return { uri: data.uri, cid: data.cid }
}

